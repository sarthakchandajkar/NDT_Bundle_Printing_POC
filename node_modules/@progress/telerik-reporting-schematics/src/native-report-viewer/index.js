"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addModuleImportToNgModule = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const add_declaration_to_ng_module_1 = require("@schematics/angular/utility/add-declaration-to-ng-module");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const find_module_1 = require("@schematics/angular/utility/find-module");
const parse_name_1 = require("@schematics/angular/utility/parse-name");
const validation_1 = require("@schematics/angular/utility/validation");
const workspace_1 = require("@schematics/angular/utility/workspace");
const schema_1 = require("./schema");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const ts = require("@schematics/angular/third_party/github.com/Microsoft/TypeScript/lib/typescript");
const change_1 = require("@schematics/angular/utility/change");
const semver = require("semver");
function setDefaults(options) {
    if (!options.serviceUrl && !options.report) {
        options.serviceUrl = "https://demos.telerik.com/reporting/api/reports",
            options.report = "Report Catalog.trdx";
    }
}
function addModuleImportToNgModule(options) {
    return (host) => {
        const modulePath = options.module;
        if (options.skipImport || options.standalone || !modulePath) {
            return host;
        }
        const sourceText = host.readText(modulePath);
        const source = ts.createSourceFile(modulePath, sourceText, ts.ScriptTarget.Latest, true);
        const changes = (0, ast_utils_1.addImportToModule)(source, modulePath, options.className, options.importPath);
        const recorder = host.beginUpdate(modulePath);
        for (const change of changes) {
            if (change instanceof change_1.InsertChange) {
                recorder.insertLeft(change.pos, change.toAdd);
            }
        }
        host.commitUpdate(recorder);
        return host;
    };
}
exports.addModuleImportToNgModule = addModuleImportToNgModule;
function buildSelector(options, projectPrefix) {
    let selector = schematics_1.strings.dasherize(options.name);
    if (options.prefix) {
        selector = `${options.prefix}-${selector}`;
    }
    else if (options.prefix === undefined && projectPrefix) {
        selector = `${projectPrefix}-${selector}`;
    }
    return selector;
}
function computeDefaultStandalone(options, host, project) {
    var _a;
    const packageJsonPath = project.root + "/package.json";
    if (host.exists(packageJsonPath)) {
        try {
            const packageJson = JSON.parse(host.read(packageJsonPath).toString("utf-8"));
            const angularVersion = semver.minVersion((_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.dependencies) === null || _a === void 0 ? void 0 : _a["@angular/core"]);
            if (angularVersion && angularVersion.major <= 13 && options.standalone) {
                throw new Error("The --standalone is not supported on Angular 13");
            }
            else if (angularVersion && angularVersion.major <= 16) {
                options.standalone = false;
            }
            else if (angularVersion) {
                options.standalone = true;
            }
        }
        catch (_b) {
            // we will stick with the default version
        }
    }
}
function default_1(options) {
    return (host) => __awaiter(this, void 0, void 0, function* () {
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = workspace.projects.get(options.project);
        if (!project) {
            throw new schematics_1.SchematicsException(`Project "${options.project}" does not exist.`);
        }
        if (options.path === undefined) {
            options.path = (0, workspace_1.buildDefaultPath)(project);
        }
        options.module = (0, find_module_1.findModuleFromOptions)(host, options);
        const parsedPath = (0, parse_name_1.parseName)(options.path, options.name);
        options.name = parsedPath.name;
        options.path = parsedPath.path;
        options.selector =
            options.selector || buildSelector(options, (project && project.prefix) || '');
        (0, validation_1.validateHtmlSelector)(options.selector);
        setDefaults(options);
        computeDefaultStandalone(options, host, project);
        const skipStyleFile = options.inlineStyle || options.style === schema_1.Style.None;
        const templateSource = (0, schematics_1.apply)((0, schematics_1.url)('./files'), [
            options.skipTests ? (0, schematics_1.filter)((path) => !path.endsWith('.spec.ts.template')) : (0, schematics_1.noop)(),
            skipStyleFile ? (0, schematics_1.filter)((path) => !path.endsWith('.__style__.template')) : (0, schematics_1.noop)(),
            options.inlineTemplate ? (0, schematics_1.filter)((path) => !path.endsWith('.html.template')) : (0, schematics_1.noop)(),
            (0, schematics_1.applyTemplates)(Object.assign(Object.assign(Object.assign({}, schematics_1.strings), { 'if-flat': (s) => (options.flat ? '' : s) }), options)),
            !options.type
                ? (0, schematics_1.forEach)(((file) => {
                    return file.path.includes('..')
                        ? {
                            content: file.content,
                            path: file.path.replace(/\.\./g, '.'),
                        }
                        : file;
                }))
                : (0, schematics_1.noop)(),
            (0, schematics_1.move)(parsedPath.path),
        ]);
        // TODO: If !standalone, add module: import { ReportingAngularViewerModule } from '@progress/telerik-angular-native-report-viewer';
        return (0, schematics_1.chain)([
            (0, add_declaration_to_ng_module_1.addDeclarationToNgModule)(Object.assign({ type: 'component' }, options)),
            addModuleImportToNgModule(Object.assign(Object.assign({}, options), { className: "BrowserAnimationsModule", importPath: "@angular/platform-browser/animations" })),
            addModuleImportToNgModule(Object.assign(Object.assign({}, options), { className: "ReportingAngularViewerModule", importPath: "@progress/telerik-angular-native-report-viewer" })),
            (tree, context) => {
                var _a, _b, _c, _d, _e;
                (0, dependencies_1.addPackageJsonDependency)(tree, {
                    type: dependencies_1.NodeDependencyType.Dev,
                    name: '@progress/telerik-angular-native-report-viewer',
                    version: '*',
                    overwrite: true,
                });
                const packageJsonPath = project.root + "/package.json";
                let localizeVersion = "^17.0.0";
                if (tree.exists(packageJsonPath)) {
                    try {
                        const packageJson = JSON.parse(host.read(packageJsonPath).toString("utf-8"));
                        const angularVersion = semver.minVersion((_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.dependencies) === null || _a === void 0 ? void 0 : _a["@angular/core"]);
                        if (angularVersion) {
                            localizeVersion = `^${angularVersion.major}.0.0`;
                        }
                    }
                    catch (_f) { }
                }
                (0, dependencies_1.addPackageJsonDependency)(tree, {
                    type: dependencies_1.NodeDependencyType.Dev,
                    name: '@angular/localize',
                    version: localizeVersion,
                    overwrite: true,
                });
                try {
                    const configPath = project.root + "/angular.json";
                    if (tree.exists(configPath)) {
                        const json = JSON.parse(tree.read(configPath).toString("utf-8"));
                        const buildOptions = (_e = (_d = (_c = (_b = json === null || json === void 0 ? void 0 : json.projects) === null || _b === void 0 ? void 0 : _b[options.project]) === null || _c === void 0 ? void 0 : _c.architect) === null || _d === void 0 ? void 0 : _d.build) === null || _e === void 0 ? void 0 : _e.options;
                        if (buildOptions) {
                            const styles = (buildOptions === null || buildOptions === void 0 ? void 0 : buildOptions.styles) || [];
                            // Check if there is a kendo theme in styles, and if there is none - add one.
                            if (!styles.reduce((acc, next) => acc || next.includes("@progress/kendo-theme-"), false)) {
                                styles.push("node_modules/@progress/kendo-theme-default/dist/default-ocean-blue.scss");
                                buildOptions.styles = styles;
                                // This may be better at editing and preserving formatting, but the API is not so straight forward to set styles: import { updateWorkspace } from "@schematics/angular/utility/workspace";
                                host.overwrite(configPath, JSON.stringify(json, null, 2));
                                (0, dependencies_1.addPackageJsonDependency)(tree, {
                                    type: dependencies_1.NodeDependencyType.Dev,
                                    name: '@progress/kendo-theme-default',
                                    version: "~7.0.0",
                                    overwrite: true
                                });
                            }
                        }
                    }
                }
                catch (e) {
                    console.log(`Error while trying to add kendo theme: ${e}`);
                }
                const npmi = context.addTask(new tasks_1.NodePackageInstallTask(), []);
                context.addTask(new tasks_1.RunSchematicTask("@angular/localize", "ng-add", {}), [npmi]);
                return tree;
            },
            (0, schematics_1.mergeWith)(templateSource),
        ]);
    });
}
exports.default = default_1;
//# sourceMappingURL=index.js.map